# Multidown 技术栈选型分析

> 目标：体积小、运行快速、跨平台、开发维护方便、界面美观

---

## 一、目标与权重（简要）

| 目标         | 说明                           |
|--------------|--------------------------------|
| 体积小       | 安装包/单文件尽量小，便于分发 |
| 运行快速     | 启动快、占用内存低、下载逻辑高效 |
| 跨平台       | Windows / macOS / Linux 一套代码 |
| 开发维护方便 | 上手快、生态成熟、调试部署简单 |
| 界面美观     | 现代 UI、可定制、动效与体验好 |

---

## 二、候选方案对比

### 2.1 总体对比表

| 方案            | 体积(约)     | 运行/内存     | 跨平台 | 开发维护     | 界面美观度   |
|-----------------|-------------|---------------|--------|--------------|--------------|
| **Tauri 2**     | ⭐⭐⭐⭐⭐ 3–8 MB | ⭐⭐⭐⭐⭐ 快/省内存 | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐ 需一点 Rust | ⭐⭐⭐⭐⭐ Web 任意 |
| **Wails 2 + Go**| ⭐⭐⭐⭐ 10–20 MB | ⭐⭐⭐⭐⭐ 快      | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐⭐ Go 简单   | ⭐⭐⭐⭐⭐ Web 任意 |
| **Flutter**     | ⭐⭐⭐ 15–35 MB | ⭐⭐⭐⭐ 较好    | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐ 单语言   | ⭐⭐⭐⭐  Material/自定义 |
| **Avalonia (C#)**| ⭐⭐ 20–80 MB | ⭐⭐⭐⭐ 较好    | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐ C# 生态   | ⭐⭐⭐⭐  XAML |
| **Electron**    | ⭐ 80–150 MB | ⭐⭐ 慢/占内存  | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐⭐ 纯前端   | ⭐⭐⭐⭐⭐ Web 任意 |

- **Electron**：体积与内存与「体积小、运行快」冲突明显，**不推荐**。
- **Avalonia**：自包含体积大（约 80MB），若要小体积需依赖系统 .NET，**不太符合“体积小”优先**。
- 下面重点说明 **Tauri 2**、**Wails 2 + Go**、**Flutter** 三种。

---

## 三、推荐方案一：Tauri 2（Rust + Web 前端）

### 特点

- **体积**：使用系统 WebView，安装包约 **3–8 MB**，最小可到约 600KB 级。
- **运行**：核心逻辑用 Rust，多线程/异步、网络 I/O 非常合适；内存常为几十 MB 级。
- **跨平台**：Windows / macOS / Linux 一套代码；Tauri 2 还支持 Android / iOS。
- **界面**：前端用 **任意 Web 技术**（React / Vue / Svelte / 原生等），UI 上限高、易做美观。
- **维护**：Rust 侧适合做「下载引擎、分段、连接池」等稳定核心；前端可独立迭代。

### 适合你的原因

1. **下载引擎与 Rust 天然契合**：多连接、Range、动态分段、文件按 offset 写入，Rust 的 `reqwest`、`tokio`、内存安全与零成本抽象都很合适；开源里已有 Rust 下载器（如 Grapple、Trauma）可参考。
2. **体积与性能同时满足**：二进制小、启动快、长时间挂下载任务也省资源。
3. **界面完全自由**：用成熟前端栈做列表、进度、设置、主题，容易做出「界面美观」。

### 代价与应对

- **需要学一点 Rust**：主要用在「下载核心」和与 Tauri 的桥接；业务逻辑量不大，可边写边学。
- **构建与调试**：需配置 Rust 环境；Tauri 文档全，社区活跃，遇到问题容易查。

### 技术组成建议

| 层级     | 技术选型说明 |
|----------|----------------|
| 前端 UI  | React / Vue / Svelte + Tailwind（或你熟悉的一套） |
| 桌面壳   | Tauri 2（Rust） |
| 下载引擎 | Rust：`reqwest`（或 `ureq`）+ `tokio`，自定义分段/连接池 |
| 进程内通信 | Tauri Commands / 事件，前端调 Rust 接口 |

**结论**：若你**优先保证「体积小 + 运行快 + 界面美观」**，并能接受为下载核心学一部分 Rust，**首选 Tauri 2**。

---

## 四、推荐方案二：Wails 2 + Go（Go + Web 前端）

### 特点

- **体积**：单二进制约 **10–20 MB**（含 WebView），可用 UPX 再压，仍远小于 Electron。
- **运行**：Go 编译为原生码，协程和标准库 `net/http` 足够做多连接下载，性能好、内存可控。
- **跨平台**：一套 Go 代码，编译 Win/Mac/Linux；Wails 负责把前端打包进同一可执行文件。
- **界面**：同样用 **Web 技术**（React / Vue / Svelte 等），美观度与 Tauri 同档。
- **维护**：**开发维护最友好**——Go 语法简单、依赖少、构建一条命令；前端与 Tauri 一样可独立迭代。

### 适合你的原因

1. **开发效率高**：若你或团队更熟 Go/Web、不想深入 Rust，Wails 是「一条命令跑、一条命令打包」的体验。
2. **下载逻辑好写**：Go 的 goroutine + `net/http` + 标准库即可实现多连接、Range、断点续传；代码清晰、易维护。
3. **体积与性能平衡**：比 Tauri 略大，但仍是「小体积、运行快」范畴。

### 代价与应对

- **体积比 Tauri 大几 MB**：若对「安装包尽量小」有硬指标，Tauri 更优；否则 Wails 完全可接受。
- **Go 的 UI 生态在桌面端不如 Rust+Tauri 成熟**：但 Wails 用 Web 做 UI，不存在「Go 做界面」的问题。

### 技术组成建议

| 层级     | 技术选型说明 |
|----------|----------------|
| 前端 UI  | React / Vue / Svelte + Tailwind（与 Tauri 可共用设计） |
| 桌面壳   | Wails 2（Go） |
| 下载引擎 | Go：`net/http` 或 `resty`/`reqwest-go`，自定义分段与连接池 |
| 前后端通信 | Wails 的 Bind / 事件，前端调 Go 方法 |

**结论**：若你**更看重「开发维护方便」且希望尽量少学新语言**，**首选 Wails 2 + Go**；体积和运行速度仍能很好满足目标。

---

## 五、备选方案：Flutter 桌面

### 特点

- **体积**：Release 约 **15–35 MB**（视平台与依赖），介于 Tauri 与 Electron 之间。
- **运行**：Dart AOT 编译，启动和运行都不错，内存中等。
- **跨平台**：Win/Mac/Linux（及移动端）一套代码。
- **维护**：单语言 Dart，UI 与逻辑同一套，热重载体验好。
- **界面**：Material / Cupertino + 自定义，能做出不错界面，但不如「Web 组件库 + CSS」那么灵活。

### 适合场景

- 团队已有 Flutter 经验，或希望**桌面 + 移动**共享 UI 与部分逻辑。
- 能接受**体积比 Tauri/Wails 大一些**，且下载引擎用 Dart 实现（或通过 FFI 调 C/Rust/Go 库）。

### 不太适合的原因

- 做「多连接 + Range + 动态分段」在 Dart 里要自己造轮子或 FFI；没有像 Rust/Go 那样多的现成下载器参考。
- 若要「体积尽量小」，Flutter 不如 Tauri/Wails。

**结论**：**有 Flutter 背景或打算做多端统一时再优先考虑**；否则更推荐 Tauri 或 Wails。

---

## 六、综合推荐与选择建议

### 6.1 按你的目标排序后的推荐

1. **最均衡（体积小 + 快 + 美观 + 可维护）**  
   → **Tauri 2**  
   - 体积最小、运行最快，界面用 Web 任意发挥；代价是下载核心用 Rust，需一定学习成本。

2. **最省心（开发维护方便优先）**  
   → **Wails 2 + Go**  
   - 体积和性能仍然很好，上手快、维护简单，界面同样用 Web 做美观。

3. **已有 Flutter 或强需求多端一致**  
   → **Flutter 桌面**  
   - 体积和性能中等，单语言与热重载对迭代友好。

### 6.2 选择决策简表

| 你的情况                     | 更合适的方案   |
|-----------------------------|----------------|
| 能接受学 Rust，追求最小体积、最快 | **Tauri 2**    |
| 想快速出产品、团队偏 Go/Web     | **Wails 2 + Go** |
| 已有 Flutter 或要做移动端       | **Flutter**    |
| 必须「安装包尽量小」且要好看     | **Tauri 2**    |

### 6.3 与「IDM 对标」的匹配度

- **下载引擎**：Rust（Tauri）和 Go（Wails）都**非常适合**实现多连接、Range、动态分段、断点续传；现有开源下载器也有 Rust/Go 实现可参考。
- **UI**：Tauri 与 Wails 都使用 Web 前端，便于做任务列表、速度曲线、设置页等「界面美观」的界面。
- **跨平台**：三者均支持 Win/Mac/Linux，满足「跨平台」目标。

---

## 七、建议的下一步

1. **若选 Tauri 2**  
   - 初始化 Tauri 2 项目（前端用你熟悉的框架）。  
   - 在 Rust 侧先实现「多连接 + 静态分段 + 断点续传」的最小引擎，再升级为动态分段。  

2. **若选 Wails 2 + Go**  
   - 用 `wails init` 创建项目，前端同上。  
   - 在 Go 侧实现同样的下载引擎逻辑，通过 Wails Bind 暴露给前端。  

3. **统一**  
   - 先做 **CLI 或无 UI 的下载核心**（Rust 或 Go），验证 Range、分段、续传逻辑；再加 Tauri/Wails 壳和 UI，可降低返工风险。

如果你确定选 **Tauri** 或 **Wails**，我可以按你选的栈，下一步直接给出「项目结构 + 下载引擎接口设计 + 第一个可运行示例」的落地方案（含目录和关键代码骨架）。
